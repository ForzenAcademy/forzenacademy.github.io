// Generated by dts-bundle-generator v9.5.1

export type ArgumentSet = {
	[key: string]: any;
};
export interface PrefabDefinition {
	id: string;
	args: ArgumentSet;
	enabled: boolean;
}
export declare class RgbColor {
	r: number;
	g: number;
	b: number;
	static none: RgbColor;
	static red: RgbColor;
	static darkred: RgbColor;
	static green: RgbColor;
	static darkgreen: RgbColor;
	static lightblue: RgbColor;
	static blue: RgbColor;
	static darkblue: RgbColor;
	static black: RgbColor;
	static white: RgbColor;
	static magenta: RgbColor;
	static yellow: RgbColor;
	static mc1: RgbColor;
	static mc2: RgbColor;
	static mc3: RgbColor;
	static mc4: RgbColor;
	static gs2: RgbColor;
	static gs3: RgbColor;
	static icecream1: RgbColor;
	static icecream2: RgbColor;
	static icecream3: RgbColor;
	static icecream4: RgbColor;
	static sepia1: RgbColor;
	static sepia2: RgbColor;
	static sepia3: RgbColor;
	static sepia4: RgbColor;
	static blue2: RgbColor;
	static blue3: RgbColor;
	static lemonlime1: RgbColor;
	static lemonlime2: RgbColor;
	static lemonlime3: RgbColor;
	static lemonlime4: RgbColor;
	static orangeblue1: RgbColor;
	static orangeblue2: RgbColor;
	static orangeblue3: RgbColor;
	static orangeblue4: RgbColor;
	static greenblue1: RgbColor;
	static greenblue2: RgbColor;
	static greenblue3: RgbColor;
	static greenblue4: RgbColor;
	static rustic1: RgbColor;
	static rustic2: RgbColor;
	static rustic3: RgbColor;
	static rustic4: RgbColor;
	static mist1: RgbColor;
	static mist2: RgbColor;
	static mist3: RgbColor;
	static mist4: RgbColor;
	static wish1: RgbColor;
	static wish2: RgbColor;
	static wish3: RgbColor;
	static wish4: RgbColor;
	static crimson1: RgbColor;
	static crimson2: RgbColor;
	static crimson3: RgbColor;
	static crimson4: RgbColor;
	static spacehaze1: RgbColor;
	static spacehaze2: RgbColor;
	static spacehaze3: RgbColor;
	static spacehaze4: RgbColor;
	static aqua1: RgbColor;
	static aqua2: RgbColor;
	static aqua3: RgbColor;
	static aqua4: RgbColor;
	static nostalgia1: RgbColor;
	static nostalgia2: RgbColor;
	static nostalgia3: RgbColor;
	static nostalgia4: RgbColor;
	static purple1: RgbColor;
	static purple2: RgbColor;
	static purple3: RgbColor;
	static purple4: RgbColor;
	static autumn1: RgbColor;
	static autumn2: RgbColor;
	static autumn3: RgbColor;
	static autumn4: RgbColor;
	static firey1: RgbColor;
	static firey2: RgbColor;
	static firey3: RgbColor;
	static firey4: RgbColor;
	static mint1: RgbColor;
	static mint2: RgbColor;
	static mint3: RgbColor;
	static mint4: RgbColor;
	static amber1: RgbColor;
	static amber2: RgbColor;
	static amber3: RgbColor;
	static amber4: RgbColor;
	static coral1: RgbColor;
	static coral2: RgbColor;
	static coral3: RgbColor;
	static coral4: RgbColor;
	constructor(r?: number, g?: number, b?: number);
	equals(other: RgbColor): boolean;
	clear(): void;
	grey(v: number): void;
	set(color: RgbColor): void;
	isNone(): boolean;
	copy(): RgbColor;
	static getHexColorString(color: RgbColor): string;
}
export interface Rgb {
	r: number;
	g: number;
	b: number;
}
export declare class ColorFilter {
	map: ColorFilterMap;
	fallbackColor: RgbColor;
	constructor(map: ColorFilterMap, fallbackColor: RgbColor);
	copy(): ColorFilter;
	get(c: string): RgbColor;
	static monoChromeFilter: ColorFilter;
	static gameboyGreyscaleFilter: ColorFilter;
	static nostalgiaFilter: ColorFilter;
	static fromRgbArray(colors: Rgb[]): ColorFilter;
}
export type ColorFilterMap = {
	[key: string]: RgbColor;
};
export declare function monoColorFilter(color: RgbColor): ColorFilter;
export declare class Bitmap {
	width: number;
	height: number;
	data: string;
	filter: ColorFilter | null;
	constructor(width: number, height: number, data: string, filter?: ColorFilter | null);
	static rect(color: string, width: number, height: number): Bitmap;
	mask(x1: number, y1: number, x2: number, y2: number): Bitmap;
	/**
	 * Get a copy of this Bitmap flipped horizontally
	 *
	 * @returns A copy of this Bitmap flipped horizontally
	 */
	flipHorizontally(): Bitmap;
	/**
	 * Get a copy of this Bitmap flipped vertically
	 *
	 * @returns A copy of this Bitmap flipped vertically
	 */
	flipVertically(): Bitmap;
	/**
	 * Returns a copy of this bitmap rotated 270 degrees
	 *
	 * @returns A bitmap that is a representation of the original bitmap flipped 270 degrees
	 */
	rotate90(): Bitmap;
	/**
	 * Returns a copy of this bitmap rotated 270 degrees
	 *
	 * @returns A bitmap that is a representation of the original bitmap flipped 270 degrees
	 */
	rotate180(): Bitmap;
	/**
	 * Returns a copy of this bitmap rotated 270 degrees
	 *
	 * @returns A bitmap that is a representation of the original bitmap flipped 270 degrees
	 */
	rotate270(): Bitmap;
	letterMap(map: {
		[key: string]: string;
	}): Bitmap;
	setFilter(filter: ColorFilter): Bitmap;
}
export declare class AnimationSequence {
	frameTime: number;
	onLoop: (() => void) | null;
	private sprites;
	private internalTimer;
	private currentIndex;
	constructor(sprites: Bitmap[], frameTime?: number, onLoop?: (() => void) | null);
	update(): void;
	getCurrentFrame(): number;
	get(): Bitmap;
	reset(): void;
}
export declare class AnimationKeySequence {
	frameTime: number;
	onLoop: (() => void) | null;
	doesRepeat: boolean;
	onEnd: (() => void) | null;
	private keys;
	private internalTimer;
	private currentIndex;
	private hasEnded;
	constructor(keys: number[], frameTime?: number, onLoop?: (() => void) | null, doesRepeat?: boolean, onEnd?: (() => void) | null);
	update(): void;
	getCurrentFrame(): number;
	getInternalTimer(): number;
	get(): Bitmap;
	reset(): void;
	setCurrentFrame(frame: number, internalTimer?: number): void;
}
export interface ColorPalette {
	colors: Rgb[];
}
export interface Box {
	x: number;
	y: number;
	width: number;
	height: number;
}
export type BitmapDictionary = {
	[key: string]: Bitmap;
};
export type Size = {
	width: number;
	height: number;
};
export declare class Font {
	private charMap;
	private fallback;
	constructor(charMap: BitmapDictionary, fallback: Bitmap);
	get(c: string): Bitmap;
	measure(text: string, kerning?: number): Size;
	measureWrapped(text: string, maxWidth: number, kerning?: number, lineSpacing?: number): Size;
}
export interface AssetManager {
	getBitmap(id: number): Bitmap;
	getBitmapByName(id: string): Bitmap;
	getFilter(id: number): ColorFilter | undefined;
	getFilterByName(id: string): ColorFilter | undefined;
	getMap(id: number, fallback?: RgbColor): MapAssetDefinition | undefined;
	getMapByName(id: string): MapAssetDefinition | undefined;
	getFilterByName(id: string): ColorFilter | undefined;
	getAnimation(id: number): AnimationKeySequence | undefined;
	getAnimationByName(id: string): AnimationKeySequence | undefined;
	getFont(id: number): Font | undefined;
	getFontByName(id: string): Font | undefined;
}
export interface DrawableAssetDefinition {
	name: string;
	data: string;
	width: number;
	height: number;
	preferredFilter?: string;
}
export interface ColorPaletteAssetDefinition {
	name: string;
	palette: ColorPalette;
}
export interface MapAssetDefinition {
	name: string;
	data: string;
	width: number;
	height: number;
	map: {
		[key: string]: MapTileDefinition;
	};
	colliders: Box[];
	prefabs: PrefabDefinition[];
}
export interface MapTileDefinition {
	name?: string;
	animated?: boolean;
}
export declare function setAssetManager(assetManager: AssetManager): void;
export declare let Assets: AssetManager;
export declare class DefaultAssets {
	static ncursor_1: Bitmap;
	static ncursor_2: Bitmap;
	static scursor_1: Bitmap;
	static scursor_2: Bitmap;
}
export declare class Note {
	frequency: number;
	duration: number;
	gain: number;
	slideFrequency: boolean;
	slideGain: boolean;
	constructor(frequency: number, duration: number, gain: number, slideFrequency?: boolean, slideGain?: boolean);
}
export declare const MusicNotes: {
	[key: string]: number;
};
export declare abstract class Instrument {
	private DECAY_STEP;
	protected player: AudioPlayer | null;
	protected oscillator: OscillatorNode | null;
	protected gain: GainNode | null;
	protected waveShaper: WaveShaperNode | null;
	private notes;
	private currentIndex;
	private currentTimer;
	private playing;
	private initialized;
	private trackLength;
	reset(): void;
	setTrack(notes: Note[]): void;
	destroy(): void;
	isDestroyed(): boolean;
	initialize(audioContext: AudioContext, player: AudioPlayer): void;
	abstract innerInitialize(audioContext: AudioContext): void;
	start(): void;
	stop(): void;
	set(frequency: number, gain: number): void;
	setFrequency(frequency: number): void;
	setGain(gain: number): void;
	update(): void;
	powerOff(): void;
	private powerDown;
	private loadNote;
	abstract innerLoadNote(note: Note): void;
	abstract innerStart(): void;
}
export declare class SquareInstrument extends Instrument {
	innerStart(): void;
	innerLoadNote(): void;
	innerInitialize(audioContext: AudioContext): void;
}
export declare class PulseInstrument extends Instrument {
	private real0;
	private imag0;
	private real1;
	private imag1;
	private real2;
	private imag2;
	private currentDuty;
	constructor();
	innerStart(): void;
	innerLoadNote(note: Note): void;
	innerInitialize(audioContext: AudioContext): void;
	private loadDuty;
}
export declare class TriangleInstrument extends Instrument {
	innerStart(): void;
	innerLoadNote(): void;
	innerInitialize(audioContext: AudioContext): void;
}
export declare class NoiseInstrument extends Instrument {
	private context;
	private noise;
	private filter;
	private noiseBuffer;
	private output;
	innerLoadNote(note: Note): void;
	innerStart(): void;
	innerInitialize(audioContext: AudioContext): void;
}
/**
 * I need an AudioMixer and AudioPlayer
 * Mixer will orchestrate the clips/songs that are playing
 * AudioPlayer will be an instance of a player that the mixer manages, with independent volume etc
 */
export declare enum InstrumentType {
	SQUARE = 0,
	TRIANGLE = 1,
	PULSE_D0 = 2,
	PULSE_D1 = 3,
	PULSE_D2 = 4,
	PULSE_D3 = 5,
	NOISE_LOW = 6,
	NOISE_HIGH = 7
}
export interface AudioTrackDefinition {
	data: string;
	instrumentType: InstrumentType;
	doesRepeat: boolean;
	onDoneListener?: () => void;
	volume?: number;
}
export interface AudioMixer {
	getVolume(): number;
	setVolume(volume: number): void;
	playSoundClip(params: AudioTrackDefinition): AudioPlayer;
	update(): void;
	stopAll(): void;
}
export interface AudioPlayer {
	getVolume(): number;
	setVolume(volume: number): void;
	getDoesRepeat(): boolean;
	setDoesRepeat(doesRepeat: boolean): void;
	setOnDoneListener(listener: () => void): void;
	update(): void;
	stop(): void;
	getCurrentTime(): number;
	getSongLength(): number;
	getSongRemainingFrames(): number;
	setInstrumentAsDone(instrument: Instrument): void;
	getIsDonePlaying(): boolean;
	_createPeriodicWave(real: Iterable<number>, imag: Iterable<number>, constraints?: PeriodicWaveConstraints): PeriodicWave;
}
declare class AudioPlayerImpl implements AudioPlayer {
	private audioContext;
	private hasInitializedOscillators;
	private volume;
	private doesRepeat;
	private onDoneListener;
	private currentTrack;
	private instruments;
	private isStillPlayingChannel;
	songLength: number;
	remainingFrames: number;
	constructor(params: AudioTrackDefinition);
	setInstrumentAsDone(instrument: Instrument): void;
	getSongLength(): number;
	getSongRemainingFrames(): number;
	getCurrentTime(): number;
	getDoesRepeat(): boolean;
	setDoesRepeat(doesRepeat: boolean): void;
	getVolume(): number;
	setVolume(volume: number): void;
	update(): void;
	setOnDoneListener(listener: () => void): void;
	stop(): void;
	_createPeriodicWave(real: Iterable<number>, imag: Iterable<number>): PeriodicWave;
	getIsDonePlaying(): boolean;
	test(song: string): void;
	private initializeOscillators;
	private play;
}
declare class AudioMixerImpl implements AudioMixer {
	static audioContext: AudioContext;
	private audioPlayers;
	private volume;
	constructor();
	playSoundClip(params: AudioTrackDefinition): AudioPlayer;
	update(): void;
	stopAll(): void;
	getVolume(): number;
	setVolume(volume: number): void;
}
export declare const AUDIO: AudioPlayerImpl;
export declare const A_MIXER: AudioMixerImpl;
export declare class AudioParser {
	static parse(song: string): Note[];
	static encode(notes: Note[]): string;
}
export declare class BackgroundData {
	tileWidth: number;
	tileHeight: number;
	tileDataMap: (BackgroundTile | null)[];
	colliders: Box[];
	constructor(tileWidth: number, tileHeight: number, tileDataMap: (BackgroundTile | null)[], colliders: Box[]);
}
export declare abstract class BackgroundTile {
	abstract getBitmap(): Bitmap;
}
export declare class NormalBackgroundTile extends BackgroundTile {
	imgName: string;
	constructor(imgName: string);
	getBitmap(): Bitmap;
}
export declare class AnimatedBackgroundTile extends BackgroundTile {
	private animation?;
	constructor(animationName: string);
	getBitmap(): Bitmap;
}
declare class BuildConfig {
	type: "DEBUG" | "RELEASE";
	constructor(type?: "DEBUG" | "RELEASE");
}
export declare const BUILDCONFIG: BuildConfig;
export declare class Point {
	x: number;
	y: number;
	constructor(x?: number, y?: number);
	vectorMagnitude(): number;
	vectorNormalize(): Point;
	static subtractPoints(a: Point, b: Point): Point;
	static getPointAtDistanceAndAngle(x: number, y: number, r: number, angle: number): Point;
}
export declare class Point3 {
	x: number;
	y: number;
	z: number;
	constructor(x?: number, y?: number, z?: number);
}
/**
 * ColorLightMap
 *
 * Maps a "base palette" color to its corresponding darker/lighter variants (same index).
 *
 * - baseColors[i] <-> darker[i] <-> lighter[i]
 * - resolve(color, delta):
 *    delta === 0  -> base color (or original if not in base)
 *    delta < 0    -> darker variant (or black if not in base)
 *    delta > 0    -> lighter variant (or white if not in base)
 *
 * Fast lookups:
 * - Builds an O(1) Map keyed by RGB24 (r<<16|g<<8|b).
 * - Also caches per-(rgb24,deltaSign) results so repeated resolves are constant-time
 *   without re-checking palette or re-instantiating common results.
 */
export declare class ColorLightMap {
	private readonly baseByRgb24;
	private readonly darker;
	private readonly lighter;
	private readonly resolveCache;
	constructor(baseColors: ReadonlyArray<RgbColor>, darker: ReadonlyArray<RgbColor>, lighter: ReadonlyArray<RgbColor>);
	private readonly resolveCacheByRgb24;
	resolve(color: RgbColor, delta: number): RgbColor;
	/** Optional: clear runtime resolve cache if palette mappings stay same but you want to free memory. */
	clearCache(): void;
	private static rgb24;
}
export declare class GraphicsProperties {
	width: number;
	height: number;
	defaultColorFilter: ColorFilter;
	constructor(width: number, height: number, defaultColorFilter: ColorFilter);
}
export declare class GameGraphics {
	static createPixelArray(width: number, height: number): RgbColorArray;
}
export type RgbColorArray = RgbColor[];
export declare class Pixels {
	private pixels;
	private width;
	private height;
	private dirty;
	private defaultColorFilter;
	constructor(properties: GraphicsProperties);
	toRgbaArray(): Uint8ClampedArray;
	isDirty(): boolean;
	setDirty(): void;
	setClean(): void;
	clear(): void;
	fillColor(color: RgbColor): void;
	drawBitmap(x: number, y: number, bitmap: Bitmap): void;
	drawLightBitmap(x: number, y: number, intensity: number, bitmap: Bitmap, colorLightMap: ColorLightMap): void;
	setPixel(x: number, y: number, color: RgbColor): void;
	strokeRectangle(x: number, y: number, width: number, height: number, color: RgbColor, thickness?: number, cornerRadius?: number): void;
	fillRectangle(x: number, y: number, width: number, height: number, color: RgbColor): void;
	fillLightRectangle(x: number, y: number, width: number, height: number, intensity: number, colorLightMap: ColorLightMap): void;
	strokeCircle(xCenter: number, yCenter: number, radius: number, color: RgbColor, thickness?: number): void;
	fillCircle(xCenter: number, yCenter: number, radius: number, color: RgbColor): void;
	strokeLightCircle(xCenter: number, yCenter: number, radius: number, intensity: number, colorLightMap: ColorLightMap, thickness?: number): void;
	fillLightCircle(xCenter: number, yCenter: number, radius: number, intensity: number, colorLightMap: ColorLightMap): void;
	strokeOval(xCenter: number, yCenter: number, radiusX: number, radiusY: number, color: RgbColor, thickness?: number): void;
	fillOval(xCenter: number, yCenter: number, radiusX: number, radiusY: number, color: RgbColor): void;
	strokeLightOval(xCenter: number, yCenter: number, radiusX: number, radiusY: number, intensity: number, colorLightMap: ColorLightMap, thickness?: number): void;
	fillLightOval(xCenter: number, yCenter: number, radiusX: number, radiusY: number, intensity: number, colorLightMap: ColorLightMap): void;
	drawLine(x1: number, y1: number, x2: number, y2: number, color: RgbColor, thickness?: number): void;
	strokeArc(xCenter: number, yCenter: number, radius: number, startAngle: number, endAngle: number, color: RgbColor, thickness?: number): void;
	fillArc(xCenter: number, yCenter: number, radius: number, startAngle: number, endAngle: number, color: RgbColor): void;
	private drawLineSimple;
	getRawData(): RgbColorArray;
}
export declare class CanvasRenderer {
	properties: GraphicsProperties;
	private pixels;
	private cachedRgbArray;
	private offscreenCanvas;
	private offscreenCtx;
	private imageData;
	private canvas;
	private colorLightMap?;
	constructor(properties: GraphicsProperties, canvas: HTMLCanvasElement);
	setColorLightMap(colorLightMap: ColorLightMap): void;
	render(): void;
	private recalculate;
	drawBitmap(x: number, y: number, bitmap: Bitmap, filter?: ColorFilter | null): void;
	drawLightBitmap(x: number, y: number, intensity: number, bitmap: Bitmap): void;
	drawBitmapCentered(x: number, y: number, bitmap: Bitmap, filter?: ColorFilter | null): void;
	drawLightBitmapCentered(x: number, y: number, intensity: number, bitmap: Bitmap): void;
	drawStaticBitmap(x: number, y: number, bitmap: Bitmap, filter?: ColorFilter | null): void;
	drawStaticBitmapCentered(x: number, y: number, bitmap: Bitmap, filter?: ColorFilter | null): void;
	drawText(text: string, x: number, y: number, font: Font, kerning?: number, filter?: ColorFilter | null): void;
	drawStaticText(text: string, x: number, y: number, font: Font, kerning?: number, filter?: ColorFilter | null): void;
	drawLightText(text: string, x: number, y: number, font: Font, kerning: number | undefined, intensity: number): void;
	drawStaticLightText(text: string, x: number, y: number, font: Font, kerning: number | undefined, intensity: number): void;
	drawTextWrapping(text: string, x: number, y: number, maxWidth: number, font: Font, kerning?: number, lineSpacing?: number): void;
	drawStaticTextWrapping(text: string, x: number, y: number, maxWidth: number, font: Font, kerning?: number, lineSpacing?: number): void;
	clear(): void;
	strokeStaticRectangle(x: number, y: number, width: number, height: number, color: RgbColor, thickness?: number, cornerRadius?: number): void;
	strokeRectangle(x: number, y: number, width: number, height: number, color: RgbColor, thickness?: number): void;
	fillStaticRectangle(x: number, y: number, width: number, height: number, color: RgbColor): void;
	fillRectangle(x: number, y: number, width: number, height: number, color: RgbColor): void;
	fillStaticLightRectangle(x: number, y: number, width: number, height: number, intensity: number): void;
	fillLightRectangle(x: number, y: number, width: number, height: number, intensity: number): void;
	strokeStaticCircle(x: number, y: number, radius: number, color: RgbColor, thickness?: number): void;
	strokeCircle(x: number, y: number, radius: number, color: RgbColor, thickness?: number): void;
	strokeLightCircle(x: number, y: number, radius: number, intensity: number, thickness?: number): void;
	strokeStaticArc(x: number, y: number, radius: number, startAngle: number, endAngle: number, color: RgbColor, thickness?: number): void;
	strokeArc(x: number, y: number, radius: number, startAngle: number, endAngle: number, color: RgbColor, thickness?: number): void;
	fillArc(x: number, y: number, radius: number, startAngle: number, endAngle: number, color: RgbColor): void;
	fillStaticArc(x: number, y: number, radius: number, startAngle: number, endAngle: number, color: RgbColor): void;
	fillStaticCircle(x: number, y: number, radius: number, color: RgbColor): void;
	fillCircle(x: number, y: number, radius: number, color: RgbColor): void;
	fillLightCircle(x: number, y: number, radius: number, intensity: number): void;
	fillStaticLightCircle(x: number, y: number, radius: number, intensity: number): void;
	strokeStaticOval(xCenter: number, yCenter: number, radiusX: number, radiusY: number, color: RgbColor, thickness?: number): void;
	fillStaticOval(xCenter: number, yCenter: number, radiusX: number, radiusY: number, color: RgbColor): void;
	strokeOval(xCenter: number, yCenter: number, radiusX: number, radiusY: number, color: RgbColor, thickness?: number): void;
	fillOval(xCenter: number, yCenter: number, radiusX: number, radiusY: number, color: RgbColor): void;
	strokeLightOval(xCenter: number, yCenter: number, radiusX: number, radiusY: number, intensity: number, thickness?: number): void;
	strokeStaticLightOval(xCenter: number, yCenter: number, radiusX: number, radiusY: number, intensity: number, thickness?: number): void;
	fillLightOval(xCenter: number, yCenter: number, radiusX: number, radiusY: number, intensity: number): void;
	fillStaticLightOval(xCenter: number, yCenter: number, radiusX: number, radiusY: number, intensity: number): void;
	fillColor(color: RgbColor): void;
	setStaticPixel(x: number, y: number, color: RgbColor): void;
	setPixel(x: number, y: number, color: RgbColor): void;
	drawStaticLine(x1: number, y1: number, x2: number, y2: number, color: RgbColor, thickness?: number): void;
	drawLine(x1: number, y1: number, x2: number, y2: number, color: RgbColor, thickness?: number): void;
	getPixelData(): Pixels;
}
export declare abstract class Lifecycle {
	fixedUpdate: () => void;
	start: () => void;
	update: () => void;
	lateUpdate: () => void;
	draw: (r: CanvasRenderer) => void;
	drawUi: (r: CanvasRenderer) => void;
	destroy: () => void;
}
/**
 * The basic Game Object used to represent a movable object on the screen.
 *
 * The @function setSize function is used with @function setDimensions to
 * compute the collision bounds.
 *
 * Store arbitrary game state data in the @property {extra} field
 *
 */
export declare class GameObject extends Lifecycle {
	name: string;
	private static instanceId;
	private instance;
	private _isDestroyed;
	_markDestroyed(): void;
	get isDestroyed(): boolean;
	DEBUG: boolean;
	DEBUG_COLOR: RgbColor;
	x: number;
	y: number;
	z: number;
	orderInLayer: number;
	vx: number;
	vy: number;
	m: number;
	linearDampingX: number;
	linearDampingY: number;
	width: number;
	height: number;
	colliderOffsetX: number;
	colliderOffsetY: number;
	ignoresCollision: boolean;
	private components;
	setSize(n: number): void;
	setDimensions(w: number, h: number): void;
	setColliderOffsets(x: number, y: number): void;
	extra: ArgumentSet;
	constructor(name: string);
	instanceId(): number;
	/** Components */
	getComponents<T extends Component>(type: new (...args: any[]) => T): T[];
	getComponents(): Component[];
	addComponent(component: Component): void;
	removeComponent(component: Component): boolean;
	removeComponent<T extends Component>(type: new (...args: any[]) => T): T[];
	getComponent<T extends Component>(type: new (...args: any[]) => T): T | undefined;
	/** Movement and collision */
	canCollideWith: (other: GameObject) => boolean;
	move(nx: number, ny: number): boolean;
	static find(name: string): GameObject | null;
	static findById(id: number): GameObject | null;
	static findObjects(filter: (go: GameObject) => boolean): GameObject[];
	static instantiate(object: GameObject, location?: Point3): GameObject;
	static destroy(object: GameObject): GameObject;
}
export declare abstract class Component extends Lifecycle {
	private _gameObject;
	private started;
	get gameObject(): GameObject;
	_startIfNeeded(): void;
	attach(gameObject: GameObject): void;
}
export interface Decoration {
	update(): void;
	getFrame(): Bitmap;
}
export declare class StaticDecoration implements Decoration {
	private bitmap;
	constructor(bitmap: Bitmap);
	update(): void;
	getFrame(): Bitmap;
}
export declare class AnimatedDecoration implements Decoration {
	private animation;
	constructor(bitmaps: Bitmap[], frameTime: number);
	update(): void;
	getFrame(): Bitmap;
}
export declare class GameDriver {
	private renderer;
	private game;
	private targetFPS;
	private targetFrameDuration;
	private lastTime;
	private running;
	constructor(game: Game, renderer: CanvasRenderer);
	getRenderProperties(): GraphicsProperties;
	setRenderer(renderer: CanvasRenderer): void;
	private update;
	private draw;
	private loop;
	start(): void;
	stop(): void;
	pause(): void;
	resume(): void;
	private STEP;
	pressUp(): void;
	liftUp(): void;
	pressDown(): void;
	liftDown(): void;
	pressLeft(): void;
	liftLeft(): void;
	pressRight(): void;
	liftRight(): void;
	pressZ(): void;
	liftZ(): void;
	pressA(): void;
	liftA(): void;
	pressB(): void;
	liftB(): void;
	pressC(): void;
	liftC(): void;
	pressD(): void;
	liftD(): void;
}
export declare abstract class Scene extends Lifecycle {
	backgroundData?: BackgroundData | undefined;
	defaultColorFilter?: ColorFilter | undefined;
	private backgroundColor;
	constructor(backgroundData?: BackgroundData | undefined, defaultColorFilter?: ColorFilter | undefined);
	onStart(): void;
	onDraw(r: CanvasRenderer): void;
}
export declare abstract class Game {
	objects: GameObject[];
	private pendingAdds;
	private pendingDels;
	protected currentScene: Scene | null;
	constructor(scene: Scene | null);
	onUpdate(): void;
	onDraw(renderer: CanvasRenderer): void;
	addObject(g: GameObject): void;
	changeScene(scene: Scene): void;
	/**
	 * Wipe all pending objects. Use with care!
	 *
	 * This should only be used to reset the game.
	 */
	wipe(): void;
	destroyObject(g: GameObject): void;
	findObjectByName(name: string): GameObject | null;
	findObjectById(id: number): GameObject | null;
	getFilteredObjects(filter: (go: GameObject) => boolean): GameObject[];
	onStart(): void;
	abstract start(): void;
	abstract update(): void;
	abstract lateUpdate(): void;
	abstract draw(renderer: CanvasRenderer): void;
	abstract drawUi(renderer: CanvasRenderer): void;
}
export declare const GAME: {
	current: Game;
};
export declare const GAMEDRIVER: {
	current: GameDriver;
};
export declare function instantiate(object: GameObject, location?: Point3): GameObject;
export declare function destroy(object: GameObject): GameObject;
export declare class Input {
	private isDown;
	private isUp;
	private isLeft;
	private isRight;
	private isA;
	private isB;
	private isC;
	private isD;
	private isZ;
	private isL;
	private isR;
	private lastIsDown;
	private lastIsUp;
	private lastIsLeft;
	private lastIsRight;
	private lastIsA;
	private lastIsB;
	private lastIsC;
	private lastIsD;
	private lastIsZ;
	private lastIsL;
	private lastIsR;
	update(): void;
	getKeyDown(key: string): boolean;
	getKeyUp(key: string): boolean;
	getKey(key: string): boolean;
	setUp(b: boolean): void;
	isUpKey(): boolean;
	setDown(b: boolean): void;
	isDownKey(): boolean;
	setLeft(b: boolean): void;
	isLeftKey(): boolean;
	setRight(b: boolean): void;
	isRightKey(): boolean;
	setZ(b: boolean): void;
	isZKey(): boolean;
	setA(b: boolean): void;
	isAKey(): boolean;
	setB(b: boolean): void;
	isBKey(): boolean;
	setC(b: boolean): void;
	isCKey(): boolean;
	setD(b: boolean): void;
	isDKey(): boolean;
}
export declare const INPUT: Input;
export type Direction = "s" | "sw" | "w" | "nw" | "n" | "ne" | "e" | "se";
export declare class DirectionUtil {
	static getAngle(d: Direction): number;
	static oppositeDirection(d: Direction): Direction;
	static getOrthogonalDirections(d: Direction): Direction[];
}
export declare class EightWayJoystick {
	lastDirection: Direction | null;
	getDirection(): Direction | null;
}
export declare class HorizontalJoystick {
	lastDirection: Direction;
	getDirection(): Direction | null;
}
export declare class Timer {
	onFinish: () => void;
	doesRepeat: boolean;
	startPrimed: boolean;
	private maxTime;
	private currentTime;
	constructor(time: number, onFinish?: () => void, doesRepeat?: boolean, startPrimed?: boolean);
	update(): void;
	stop(): void;
	reset(): void;
	setMaxTime(time: number): void;
	getFrame(): number;
	isRunning(): boolean;
}
export declare class DestroyTimer extends Component {
	readonly frames: number;
	framesLeft: number;
	constructor(frames: number);
	update: () => void;
}
export declare class Camera {
	width: number;
	height: number;
	x: number;
	y: number;
	constructor(width: number, height: number, x?: number, y?: number);
}
export declare const CAMERA: Camera;
export declare class Collision {
	static unitVectorBetweenObjects(g1: GameObject, g2: GameObject): Point;
	static distanceSquaredBetweenObjects(a: GameObject, b: GameObject): number;
	static checkIfRectanglesCollide(x1: number, y1: number, w1: number, h1: number, x2: number, y2: number, w2: number, h2: number): boolean;
	static checkIfObjectsCollide(obj1: GameObject, obj2: GameObject): boolean;
}
export declare class Vector {
	static angleBetweenPoints(x1: number, y1: number, x2: number, y2: number): number;
	static angleBetweenObjects(o1: GameObject, o2: GameObject): number;
	static targetVector(dir: Direction): Point;
	static unitVector(x1: number, y1: number, x2: number, y2: number): Point;
	static distanceSquared(x1: number, y1: number, x2: number, y2: number): number;
}
export declare class TextUtil {
	static BASE64: string;
	static b64PairInt(base64: string): number;
	static intToB64Pair(num: number): string;
	static rleimg(w: number, h: number, rle: string): Bitmap;
	static rle64img(rle: string): Bitmap;
	static stringToRle(w: number, h: number, bitmap: string, base?: number): string;
	static letterMapData(s: string, map: {
		[key: string]: string;
	}): string;
	static chunkString(s: string, w: number): string[][];
}
export declare class NextCursor {
	private animation;
	update(): void;
	get(): Bitmap;
}
export declare class SelectCursor {
	private animation;
	update(): void;
	get(): Bitmap;
}
export type RenderContext = {
	startX: number;
	startY: number;
	maxWidth: number;
	maxHeight: number;
};
export declare class GraphicSelectionCarousel extends Lifecycle {
	onRender: (r: CanvasRenderer, index: number, context: RenderContext) => void;
	cursorIndex: number;
	maxItems: number;
	constructor(onRender: (r: CanvasRenderer, index: number, context: RenderContext) => void);
	update: () => void;
}
export declare enum Alignment {
	LEFT = 0,
	CENTER = 1,
	RIGHT = 2,
	TOP = 3,
	BOTTOM = 4
}
export declare class ListItem {
	label: string;
	alignment: Alignment;
	colorString: string;
	selectable: boolean;
	constructor(label: string, alignment?: Alignment, colorString?: string, selectable?: boolean);
}
export declare class List {
	labels: ListItem[];
	constructor(labels: ListItem[]);
	draw(r: CanvasRenderer, context: RenderContext, font: Font, kerning: number, lineSpacing: number): void;
}
export declare class ScrollableList extends Lifecycle {
	labels: ListItem[];
	maxRowCount: number;
	topOffset: number;
	private ncursor;
	constructor(labels: ListItem[], maxRowCount: number);
	update: () => void;
	drawList(r: CanvasRenderer, context: RenderContext, font: Font, kerning: number, lineSpacing: number, indicatorAlignment: Alignment): void;
}
export declare class AlertDialog extends Lifecycle {
	onDismiss: () => void;
	text: string;
	padding: number;
	font: Font;
	kerning: number;
	lineSpacing: number;
	private dialog;
	private margin;
	private x;
	private y;
	private width;
	private height;
	constructor(onDismiss: () => void, text: string, alignment: Alignment, margin: number, padding: number, width: number, topLeftCorner: Bitmap, verticalSidePiece: Bitmap, font: Font, kerning: number, lineSpacing: number);
	update: () => void;
	drawUi: (r: CanvasRenderer) => void;
	getMargin(): number;
	getX(): number;
	getY(): number;
	getWidth(): number;
	getHeight(): number;
}
export declare class AlertChoiceDialog extends Lifecycle {
	onSelect: (index: number) => void;
	onDismiss: () => void;
	labels: ListItem[];
	font: Font;
	kerning: number;
	lineSpacing: number;
	private alertDialog;
	private selectionDialog;
	constructor(onSelect: (index: number) => void, onDismiss: () => void, alertDialog: AlertDialog, topLeftCorner: Bitmap, verticalSidePiece: Bitmap, labels: ListItem[], font: Font, kerning: number, lineSpacing: number);
	update: () => void;
	drawUi: (r: CanvasRenderer) => void;
}
export declare class Dialog extends Lifecycle {
	x: number;
	y: number;
	width: number;
	height: number;
	backgroundColor: RgbColor | null;
	private topLeftCorner;
	private topRightCorner;
	private bottomRightCorner;
	private bottomLeftCorner;
	private verticalSidePieceLeft;
	private verticalSidePieceRight;
	private horizontalSidePieceTop;
	private horizontalSidePieceBottom;
	constructor(x: number, y: number, width: number, height: number, topLeftCorner: Bitmap, verticalSidePiece: Bitmap, backgroundColor?: RgbColor | null);
	getFrameWidth(): number;
	getFrameHeight(): number;
	getFrameFullWidth(): number;
	getFrameFullHeight(): number;
	getRenderContext(paddingLeft?: number, paddingRight?: number, paddingTop?: number, paddingBottom?: number): RenderContext;
	drawUi: (r: CanvasRenderer) => void;
}
export declare class DialogStack extends Lifecycle {
	private stack;
	push(dialog: Lifecycle): void;
	pop(): Lifecycle | null;
	update: () => void;
	draw: (r: CanvasRenderer) => void;
	drawUi: (r: CanvasRenderer) => void;
	private getCurrent;
	isEmpty(): boolean;
	length(): number;
	clear(): void;
}
export declare class ListAlertDialog extends Lifecycle {
	onDismiss: () => void;
	labels: ListItem[];
	padding: number;
	font: Font;
	kerning: number;
	lineSpacing: number;
	private dialog;
	private margin;
	private x;
	private y;
	private width;
	private height;
	private list;
	constructor(onDismiss: () => void, labels: ListItem[], alignment: Alignment, margin: number, padding: number, width: number, topLeftCorner: Bitmap, verticalSidePiece: Bitmap, font: Font, kerning: number, lineSpacing: number);
	update: () => void;
	drawUi: (r: CanvasRenderer) => void;
	getMargin(): number;
	getX(): number;
	getY(): number;
	getWidth(): number;
	getHeight(): number;
}
export declare class ScrollableSelectionDialog extends Lifecycle {
	onSelect: (index: number) => void;
	onDismiss: () => void;
	labels: ListItem[];
	font: Font;
	kerning: number;
	lineSpacing: number;
	indicatorAlignment: Alignment;
	private dialog;
	private list;
	private scursor;
	private cursorIndex;
	private renderCursorIndex;
	showCursor: boolean;
	constructor(onSelect: (index: number) => void, onDismiss: () => void, x: number, y: number, width: number, height: number, topLeftCorner: Bitmap, verticalSidePiece: Bitmap, labels: ListItem[], font: Font, kerning: number, lineSpacing: number, maxRowCount: number, indicatorAlignment: Alignment);
	reset(): void;
	update: () => void;
	private calculateRenderCursorIndexTopOffset;
	private calculateNewRenderCursor;
	drawUi: (r: CanvasRenderer) => void;
}
export declare class GraphicSelectionCarouselDialog extends Lifecycle {
	onSelect: (index: number) => void;
	onDismiss: () => void;
	onRender: (r: CanvasRenderer, index: number, context: RenderContext) => void;
	private dialog;
	private carousel;
	private scursor;
	constructor(onSelect: (index: number) => void, onDismiss: () => void, onRender: (r: CanvasRenderer, index: number, context: RenderContext) => void, maxItems: number, x: number, y: number, width: number, height: number, topLeftCorner: Bitmap, verticalSidePiece: Bitmap);
	update: () => void;
	drawUi: (r: CanvasRenderer) => void;
	reset(): void;
}
export declare class SelectionDialog extends Lifecycle {
	onSelect: (index: number) => void;
	onDismiss: () => void;
	labels: ListItem[];
	font: Font;
	kerning: number;
	lineHeight: number;
	private dialog;
	private list;
	private scursor;
	private cursorIndex;
	showCursor: boolean;
	constructor(onSelect: (index: number) => void, onDismiss: () => void, x: number, y: number, width: number, height: number, topLeftCorner: Bitmap, verticalSidePiece: Bitmap, labels: ListItem[], font: Font, kerning: number, lineHeight: number);
	reset(): void;
	update: () => void;
	drawUi: (r: CanvasRenderer) => void;
}
export declare class ListUtil {
	static removeItem<T>(array: T[], remove: T): T[];
}
export declare class MathUtil {
	static clamp(value: number, min: number, max: number): number;
}
export declare class Random {
	static random(min: number, max: number): number;
	static coinflip(): boolean;
	static randomItem<T>(array: T[]): T;
}
export declare class TimeUtil {
	static formatMilliseconds(milliseconds: number): string;
}

export {};
